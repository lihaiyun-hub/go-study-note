# Go 语言的代码生成与 go generate

## 核心概念

- 元编程：让“代码视作数据”，可在编译期或运行期生成/变更代码。
- 代码生成：用程序产出程序，常见于枚举字符串化、序列化、Mock、ORM、协议代码等。
- Go 的取舍：运行期反射能力有限且有性能成本；更推荐编译期的生成（如 `go generate`）。

## 两类能力

- 运行期：反射，灵活但慢，类型安全与内联优化受限。
- 编译期：`go generate` 驱动的静态代码生成，可获得零反射、高性能、类型安全的实现。

## go generate 工作原理

- 在源文件中写预编译指令注释：`//go:generate <command> [args...]`（`//` 与 `go:generate` 之间无空格）。
- 显式运行：`go generate ./...` 扫描当前包内所有文件，收集并执行指令中的命令。
- 生成器通常会解析包的源代码（AST），根据语法树生成新的 `*.go` 文件，这些文件与业务代码一同参与后续 `go build`。
- 重要特性：`go generate` 不会被 `go build`、`go test` 自动触发；需要你手动运行，避免隐式副作用。

## 指令写法与约定

- 放置位置：与被生成代码相关的源文件同目录，使用注释形式指向生成命令。
- 目录语义：命令执行的工作目录是该源文件所在目录。
- 生成文件头：在生成文件顶部加入类似 `// Code generated by "tool"; DO NOT EDIT.` 提示，避免人工修改。
- 文件命名：约定俗成使用 `*_gen.go`、`*_string.go` 等后缀，便于识别与排除（必要时通过构建标记）。

## 示例：stringer 为枚举生成 String 方法

源文件添加枚举与指令：

```go
// pill.go
package painkiller

//go:generate stringer -type=Pill

type Pill int

const (
    Placebo Pill = iota
    Aspirin
    Ibuprofen
    Paracetamol
    Acetaminophen = Paracetamol
)
```

执行生成：

```bash
# 安装 stringer（首次使用）
go install golang.org/x/tools/cmd/stringer@latest

# 触发 go:generate 指令
cd path/to/pkg && go generate ./...
```

生成文件（示意）：

```go
// Code generated by "stringer -type=Pill"; DO NOT EDIT.
package painkiller

import "strconv"

func _() {
    // 如果常量值变更，会触发编译期的数组索引错误，提醒重新生成代码。
    var x [1]struct{}
    _ = x[Placebo-0]
    _ = x[Aspirin-1]
    _ = x[Ibuprofen-2]
    _ = x[Paracetamol-3]
}

const _Pill_name = "PlaceboAspirinIbuprofenParacetamol"
var _Pill_index = [...]uint8{0, 7, 14, 23, 34}

func (i Pill) String() string {
    if i < 0 || i >= Pill(len(_Pill_index)-1) {
        return "Pill(" + strconv.FormatInt(int64(i), 10) + ")"
    }
    return _Pill_name[_Pill_index[i]:_Pill_index[i+1]]
}
```

- 技巧：通过编译器检查（无效数组索引）感知枚举常量是否变更，避免运行期错误。
- 性能：`String()` 只做切片取子串与边界检查，无反射与映射开销。

## 自定义生成器的常见步骤

- 解析：使用 `go/parser`、`go/ast` 或 `golang.org/x/tools/go/packages` 读取并分析类型、常量、注解。
- 模板：用 `text/template`、`go/format` 组织目标代码，保持可读性与格式化一致。
- 产物：写入同包目录下的 `*_gen.go` 文件，标注“Code generated by …”。
- 触发：在相关源文件中加入 `//go:generate` 指令，确保团队可复现生成过程。

## 适用场景

- 枚举字符串化、错误码与状态机的友好输出。
- 高性能序列化/反序列化（避免反射），如 JSON/Proto 的静态绑定。
- 深拷贝、比较、Builder/Accessor 等样板代码自动化。
- Mock/Stub、接口适配层、API 客户端与服务端样板。
- 资源内嵌或索引生成（在 `go:embed` 无法满足的场合）。

## 反射 vs 代码生成

- 反射：灵活，开发快，但运行期开销大、类型安全弱、难以内联优化。
- 代码生成：编译期展开，零反射，易于内联与优化，适用于性能敏感与类型严格的模块。

## 最佳实践

- 显式运行生成：将 `go generate ./...` 纳入 CI 或发布流程的可选阶段，避免隐式构建副作用。
- 固定版本：对生成器加 `@version` 版本钉死，避免不同环境产出不一致。
- 变更守卫：生成文件加入编译期一致性检查（如上例中的索引校验）。
- 代码审阅：生成文件应可读、可审，必要时保留生成源（模板/规则）以便复现与维护。

## 常用命令速查

```bash
# 在当前包扫描并执行 go:generate 指令
go generate

# 递归执行所有子包
go generate ./...

# 只在一个文件触发（当指令仅存在于该文件时）
go generate path/to/file.go
```

---

