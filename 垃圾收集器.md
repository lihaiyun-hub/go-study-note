# Go 语言垃圾收集器

## 概览

- 目标：在不显著影响用户程序（Mutator）执行的前提下，回收堆上不再使用的对象，控制内存占用与延迟。
- Go GC 类型：并发标记-清除（Concurrent Mark-Sweep），以三色抽象和写屏障维护并发标记的正确性，只有在周期的起止阶段有极短的 STW。
- 关键理念：
  - 标记阶段找出“存活对象”；清除阶段回收“不可达对象”的内存。
  - 三色抽象（白/灰/黑）与“不存在黑指向白”的不变式保障并发标记正确性。
  - 写屏障与辅助标记（mark assist）将高分配速率的开销转移到分配侧，平衡 GC 与业务。
  - Pacer（节奏控制）根据 `GOGC` 目标增长率、CPU 利用率、分配速度自适应触发与配额。

## 基础算法

- 标记-清除（Mark-Sweep）
  - 标记：自根集合（Root Set）出发遍历可达对象并标记为“存活”。
  - 清除：遍历堆对象，释放未标记（不可达）的对象，将内存归还空闲链表/跨度（span）。
- 三色抽象
  - 白色：潜在垃圾；黑色：已扫描、无指向白色的外部引用；灰色：已发现但其子对象未扫描。
  - 过程：从灰色集合取对象扫描，其子对象由白变灰；灰集合清空即标记完成。
  - 不变式：整个标记过程中不允许“黑指向白”。
- 写屏障（Write Barrier）
  - 在并发标记期间拦截指针写入，让新引用的目标对象“变灰/着色”，维护三色不变式。
  - Go 使用“混合写屏障”，在堆上采用插入屏障策略（接近 Dijkstra），在栈扫描与更新上结合删除屏障（接近 Yuasa）的思想以降低暂停与开销。
- 精确扫描
  - 自 v1.3 起支持对栈内存的精确扫描（仅指针类型视为指针），显著提升标记正确性与效率。

## 工作流程（一次 GC 周期）

- 触发（Trigger）
  - 运行时根据触发条件决定是否启动 GC，典型检查由 `runtime.gcTrigger.test` 完成：
    - 堆增长触发（达到目标增长比 `GOGC` 对应的 heap goal）。
    - 时间触发（避免长时间不 GC）。
    - 周期触发或显式触发（`runtime.GC()`）。
- 标记起始（短 STW）
  - 暂停世界，开启写屏障，建立根集合快照（全局变量、栈与寄存器、数据段等）。
  - 启动后台标记 worker，分配 per-P 标记队列与工作缓冲。
- 并发标记
  - 后台标记 worker 并行遍历对象图；业务线程在分配时进行 mark assist（按字节分配承担相应标记工作）。
  - 精确栈扫描配合写屏障，确保并发期间新增或修改的指针被正确着色。
  - 工作分配采用 per-P 队列与工作窃取，降低锁竞争，提升吞吐。
- 标记终止（短 STW）
  - 确认灰集合清空，所有标记任务完成，关闭写屏障，准备清扫。
- 并发清扫（Sweep）
  - 扫描 `mspan` 回收未标记对象，归还至空闲结构；与分配器协作重用内存。
  - 清扫通常并发进行，必要时配合后台与按需清扫（`sweepone`）。
- 周期结束与下一轮
  - Pacer 根据上一轮用时、CPU 占用、分配速率调整下一轮目标（heap goal、assist 配额、worker 数量）。

## 并行与调度

- Per-P 工作队列
  - 每个处理器 P 维护独立待扫描工作，减少跨线程锁竞争。
- 工作窃取（Work Stealing）
  - 不同 P 之间窃取对方队列任务，平衡负载，避免某些 P 空闲而其他 P 过载。
- 标记 worker 类型
  - Dedicated 与 Fractional 背景标记 worker配合运行；Idle 线程也可参与标记，受 CPU 利用率与配额控制。

## 触发与节奏控制（Pacer）

- `GOGC` 与增长目标
  - `GOGC=100` 表示允许堆在上一轮终止后增长 100%（默认值），影响下一轮触发点与标记工作量。
  - 运行时可通过 `debug.SetGCPercent` 动态设置，`-1` 等价关闭自动 GC（仅手动 `runtime.GC()`）。
- 触发种类（典型）
  - Heap 触发：达到 heap goal。
  - Time 触发：间隔过长主动收集。
  - Cycle/Explicit：周期型或显式调用。
- 控制器（gcController）
  - 维护当前循环、CPU 预算、目标增长比、assist 配额等，动态决定 worker 数量与标记/清扫的节奏。

## 关键数据与结构（概念）

- 根集合（Roots）：全局指针、栈与寄存器、数据段等。
- 标记队列/缓冲（gcWork/wbuf）：待扫描对象工作集，per-P 缓冲降低竞争。
- 控制器（gcController）：循环进度、触发比、CPU 预算、配额计算与 worker 调度。
- 分配器协作：清扫将空闲对象归还 `mspan`/自由链表，分配器按对象大小与跨度类重用。

## 观测与调优

- 观测
  - `GODEBUG=gctrace=1` 输出每次 GC 的堆大小、目标、各阶段耗时、CPU 利用等。
  - `runtime.ReadMemStats` 查看堆占用、对象数、GC 次数与耗时。
- 调优建议
  - 降低短期分配速率与指针密度（值类型、复用缓冲、避免临时逃逸）。
  - 合理使用 `sync.Pool` 缓解短期分配压力（注意：每次 GC 会清空池中对象）。
  - 对延迟敏感路径：必要时暂时设置 `GOGC=-1` 并在合适时机手动 `runtime.GC()`；谨慎权衡内存与延迟。
  - 关注 mark assist 开销：高分配速率会转化为更多标记工作，必要时优化对象生命周期或批量复用。

## 历史演进（里程碑）

- v1.0：早期以 STW 为主的标记清除。
- v1.3：引入栈的精确扫描，实现真正精确的垃圾收集。
- v1.5：并发标记-清除框架成型，显著缩短 STW。
- v1.8：混合写屏障优化，进一步降低暂停与错误边界。
- v1.14：引入基于信号的真抢占式调度，GC 栈扫描更及时，减少被长循环/系统调用阻塞的栈扫描延迟。
- 后续版本：持续改进 Pacer、mark assist、worker 调度与统计可观测性。

## 常见问题与现象

- STW 尖峰：通常发生在标记起始/终止的短暂停，或在极端根集合/大栈情况下；优化栈深、减少全局可达指针密集结构可缓解。
- GC 频率过高：分配速率与目标增长比不匹配；提升 `GOGC` 或降低高频临时分配。
- Assist 过重：分配热点承担大量标记工作；采用缓冲复用、对象池或批量构造降低分配峰值。

## 术语速查

- Mutator（用户程序）、Collector（收集器）、Root Set（根集合）、Write Barrier（写屏障）。
- Mark Assist（辅助标记）、Pacer（节奏控制）、Work Stealing（工作窃取）。
- White/Gray/Black（三色）、Heap Goal（堆增长目标）。
